import 'package:flutter/material.dart';
import 'package:rp10_index_server/ammo_price.dart';
import 'package:charts_flutter/flutter.dart' as charts;
import 'package:rp10_index_viewer/data/data_manager.dart';
import 'package:rp10_index_viewer/ui/colors.dart';
import 'package:rp10_index_viewer/util/utils.dart';

class PriceSparkline extends StatelessWidget {
  final List<charts.Series<AmmoPrice, DateTime>> _seriesList;
  final bool animate;
  final DateTime first;
  final DateTime last;
  final double lastPrice;
  final bool hasOutOfStock;
  final double extentLow;
  final double extentHigh;

  factory PriceSparkline(List<AmmoPrice> prices, {bool touchMode = false, double extentLow, double extentHigh, DateTime requestedStart, DateTime requestedEnd}) {
    double highPrice = 0,
        lowPrice = 1000;
    DateTime first = DateTime(3000),
        last = DateTime(0);
    bool hasOutOfStock = false;

    for (var price in prices) {
      if(price.price == null) continue;
      if (price.price < lowPrice) lowPrice = price.price;
      if (price.price > highPrice) highPrice = price.price;
      if (price.time.isBefore(first)) first = price.time;
      if (price.time.isAfter(last)) last = price.time;

      if(!price.inStock) hasOutOfStock = true;
    }

    //print("Low price for ${prices.first.caliber}: $lowPrice");

    if(prices.length > 2) {
      for (int i = 1; i < prices.length; i++) {
        var lastQuote = prices[i-1];
        var currentQuote = prices[i];

        // Add a null quote so we get a gap
        var dataMode = DataInterval.forBounds(requestedStart, requestedEnd);
        var durationBeforeGap = Duration(hours: dataMode.hoursBetweenData(), minutes: 10);
        if(lastQuote.time.isBefore(currentQuote.time.subtract(durationBeforeGap))) {
          var dummyQuote = AmmoPrice();
          dummyQuote.price = null;
          dummyQuote.time = lastQuote.time.add(Duration(minutes: 1));
          prices.insert(i, dummyQuote);

          // Adding the quote means the old currentQuote is i+1, and we want
          // to be on the quote after currentQuote, so add 1 to i.
          i += 1;
        }
      }
    }

    var seriesList = [
      charts.Series<AmmoPrice, DateTime>(
        data: prices,
        domainFn: (datum, _) => datum.time,
        measureFn: (datum, _) => datum.price,
        id: 'Caliber Sparkline',
        colorFn: (datum, _) => datum.inStock ? ChartColors.blueGray : ChartColors.red,
        strokeWidthPxFn: (_, __) => 1.25,
      )..setAttribute(charts.measureAxisIdKey, charts.Axis.secondaryMeasureAxisId),
    ];

    return PriceSparkline._internal(
      seriesList,
      animate: false,
      first: first,
      last: last,
      lastPrice: prices.length > 0 ? prices.last.price : 0,
      hasOutOfStock: hasOutOfStock,
      extentLow: extentLow ?? lowPrice,
      extentHigh: extentHigh ?? highPrice,
    );
  }

  PriceSparkline._internal(this._seriesList, {this.animate, this.first, this.last, this.lastPrice, this.hasOutOfStock, this.extentLow, this.extentHigh});


  @override
  Widget build(BuildContext context) {
    String tooltipMessage = "";
    if(hasOutOfStock) {
      tooltipMessage += "Red segments indicate data generated by the Gunbroker Rule. ";
    }
    tooltipMessage += "Last price: \$${lastPrice?.toStringAsFixed(2)}";

    return Tooltip(
      message: tooltipMessage,
      child: charts.TimeSeriesChart(
        _seriesList,
        animate: animate,
        secondaryMeasureAxis: charts.NumericAxisSpec(
            renderSpec: charts.GridlineRendererSpec(
              tickLengthPx: 0,
              lineStyle: charts.LineStyleSpec(
                thickness: 1,
              ),
              axisLineStyle: charts.LineStyleSpec(
                thickness: 1,
                dashPattern: [0, 1]
              ),
              labelStyle: charts.TextStyleSpec(
                fontSize: 0,
              )
            ),
            viewport: charts.NumericExtents(
                extentLow, extentHigh
            ),
            tickProviderSpec: charts.StaticNumericTickProviderSpec([
              charts.TickSpec<double>(extentLow, label: ""),
              charts.TickSpec<double>((extentLow + extentHigh) / 2, label: ""),
              charts.TickSpec<double>(extentHigh, label: ""),
            ])
        ),
        defaultInteractions: false,
        domainAxis: charts.DateTimeAxisSpec(
          viewport: charts.DateTimeExtents(
            start: Utilities.getExtentStart(first, last),
            end: last,
          ),
          showAxisLine: true,
          renderSpec: charts.NoneRenderSpec<DateTime>(
            axisLineStyle: charts.LineStyleSpec(
              thickness: 1,
            )
          )
        ),
      ),
    );
  }
}